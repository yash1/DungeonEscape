public class Level
{

    private Location currentLocation;
    private Location start;
    private Location goal;
    private Cell[][] dungeon;
    private int      size;
    private DoublyLinkedDeque<Location> path;


    // ----------------------------------------------------------
    /**
     * Create a new Level object.
     *
     * @param size
     *            the size of the level
     */
    public Level(int size)
    {
        dungeon = new Cell[size][size];
        this.size = size;

        for (int i = 1; i < size - 1; i++)
        {
            for (int j = 1; j < size - 1; j++)
            {
                dungeon[i][j] = Cell.OPEN_PATH;
            }
        }

        for (int i = 0; i < size; i++)
        {
            dungeon[i][0] = Cell.WALL;
            dungeon[i][size - 1] = Cell.WALL;
            dungeon[0][i] = Cell.WALL;
            dungeon[size - 1][i] = Cell.WALL;
        }

        start = new Location(0, 0);
        currentLocation = start;
        goal = new Location(size - 1, size - 1);
        setCell(start, Cell.OPEN_PATH);
        setCell(goal, Cell.OPEN_PATH);
        path = new DoublyLinkedDeque<Location>();
        path.enqueueAtFront(currentLocation);
    }


    public void placeWalls(Location loc)
    {
        if (!loc.equals(start) && !loc.equals(goal))
        {
            dungeon[loc.x()][loc.y()] = Cell.WALL;
        }
    }

    /**
     * set the current location
     * @param loc the location to be the new current
     */
    public void setCurrentLocation(Location loc)
    {
        currentLocation = loc;
        path.enqueueAtFront(loc);
    }

    /**
     * return the current location in a location object
     * @return the current location
     */
    public Location getCurrentLocation()
    {
        return currentLocation;
    }

    /**
     * return the deque that holds the path of the dungeon explorer
     * @return the path through the dungeon
     */
    public DoublyLinkedDeque getPath()
    {
        return path;
    }


    public void removeWalls(Location loc)
    {
        if (dungeon[loc.x()][loc.y()] == Cell.WALL)
        {
            dungeon[loc.x()][loc.y()] = Cell.OPEN_PATH;
        }
    }


    public void setCell(Location loc, Cell cell)
    {
        if (!loc.equals(start) && !loc.equals(goal))
        {
            dungeon[loc.x()][loc.y()] = cell;
        }
    }


    public void setGoal(Location loc)
    {
        if (getCell(loc) != Cell.WALL && getCell(loc) != Cell.HAZARD)
        {
            goal = loc;
        }
    }


    public void setStart(Location loc)
    {
        if (getCell(loc) != Cell.WALL && getCell(loc) != Cell.HAZARD)
        {
            start = loc;
            path.clear();
            setCurrentLocation(loc);
        }
    }


    public Cell getCell(Location loc)
    {
        return dungeon[loc.x()][loc.y()];
    }


    public void restart()
    {
        for (int i = 1; i < size - 1; i++)
        {
            for (int j = 1; j < size - 1; j++)
            {
                if (dungeon[i][j] == Cell.CURRENT_PATH)
                {
                    dungeon[i][j] = Cell.OPEN_PATH;
                }
            }
        }
        setGoal(goal);
        setStart(start);
    }


    public void east()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x + 1, y));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                x++;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    public void west()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x - 1, y));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                x--;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    public void north()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x, y - 1));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                y--;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    public void south()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x, y + 1));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                y++;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }

}
