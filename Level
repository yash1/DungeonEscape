// -------------------------------------------------------------------------
/**
 * Level handles all of the data manipulation of the dungeon escape game
 *
 * @author Joe Bruzek, Yash Pant, Marcus Stewart
 * @version Dec 4, 2013
 */
public class Level
{

    private Location                    currentLocation;
    private Location                    start;
    private Location                    goal;
    private Cell[][]                    dungeon;
    private int                         size;
    private DoublyLinkedDeque<Location> path;
    private int                         index;


    // ----------------------------------------------------------
    /**
     * Create a new Level object.
     *
     * @param size
     *            the size of the level
     */
    public Level(int size)
    {
        dungeon = new Cell[size][size];
        this.size = size;

        for (int i = 1; i < size - 1; i++)
        {
            for (int j = 1; j < size - 1; j++)
            {
                dungeon[i][j] = Cell.OPEN_PATH;
            }
        }

        for (int i = 0; i < size; i++)
        {
            dungeon[i][0] = Cell.WALL;
            dungeon[i][size - 1] = Cell.WALL;
            dungeon[0][i] = Cell.WALL;
            dungeon[size - 1][i] = Cell.WALL;
        }

        start = new Location(0, 0);
        currentLocation = start;
        goal = new Location(size - 1, size - 1);
        setCell(start, Cell.OPEN_PATH);
        setCell(goal, Cell.OPEN_PATH);
        path = new DoublyLinkedDeque<Location>();
        path.enqueueAtFront(currentLocation);
    }


    /**
     * secondary constructor is used for building levels
     *
     * @param size
     *            the size of the maze
     * @param index
     *            the level index
     */
    public Level(int size, int index)
    {
        this(size);
        this.index = index;

        restart(index);
    }


    /**
     * return the index of the current maze
     *
     * @return the index of the maze
     */
    public int getIndex()
    {
        return index;
    }


    /**
     * place a wall at the location
     *
     * @param loc
     *            the location to place a new wall
     */
    public void placeWalls(Location loc)
    {
        if (!loc.equals(start) && !loc.equals(goal))
        {
            dungeon[loc.x()][loc.y()] = Cell.WALL;
        }
    }


    /**
     * set the current location
     *
     * @param loc
     *            the location to be the new current
     */
    public void setCurrentLocation(Location loc)
    {
        currentLocation = loc;
        path.enqueueAtFront(loc);
    }


    /**
     * return the current location in a location object
     *
     * @return the current location
     */
    public Location getCurrentLocation()
    {
        return currentLocation;
    }


    /**
     * return the deque that holds the path of the dungeon explorer
     *
     * @return the path through the dungeon
     */
    public DoublyLinkedDeque<Location> getPath()
    {
        return path;
    }


    /**
     * remove the wall at the current location if there is no wall, nothing
     * happens
     *
     * @param loc
     *            the location to remove the walls at
     */
    public void removeWalls(Location loc)
    {
        if (dungeon[loc.x()][loc.y()] == Cell.WALL)
        {
            dungeon[loc.x()][loc.y()] = Cell.OPEN_PATH;
        }
    }


    /**
     * set the cell to a specific cell value If the cell is the start or the
     * goal, nothing happens
     *
     * @param loc
     *            the location to have the cell changed
     * @param cell
     *            the cell value for the location to be changed to
     */
    public void setCell(Location loc, Cell cell)
    {
        if (!loc.equals(start) && !loc.equals(goal))
        {
            dungeon[loc.x()][loc.y()] = cell;
        }
    }


    /**
     * set the goal location cannot be a wall or a hazard
     *
     * @param loc
     *            the location to place the goal
     */
    public void setGoal(Location loc)
    {
        if (getCell(loc) != Cell.WALL && getCell(loc) != Cell.HAZARD)
        {
            goal = loc;
        }
    }


    /**
     * set the start location cannot be a wall or a hazard
     *
     * @param loc
     *            the location to place the start
     */
    public void setStart(Location loc)
    {
        if (getCell(loc) != Cell.WALL && getCell(loc) != Cell.HAZARD)
        {
            start = loc;
            path.clear();
            setCurrentLocation(loc);
        }
    }


    /**
     * get the value of the cell at the location
     *
     * @param loc
     *            the location to get the cell value
     */
    public Cell getCell(Location loc)
    {
        return dungeon[loc.x()][loc.y()];
    }


    /**
     * restart the dungeon level all path is removed and changed to open path
     * start and goal are reset to their original locations
     *
     * @param index
     *            the level to load
     */
    public void restart(int index)
    {
        switch (index)
        {
            case 0:
                level0();
                break;
            case 1:
                level1();
                break;
            case 2:
                level2();
                break;
            case 3:
                level3();
                break;
            case 4:
                level4();
                break;
        }
    }


    /**
     * move to the east adds the farthest east cell that can be moved to to the
     * top of the path
     */
    public void east()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x + 1, y));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                x++;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    /**
     * move to the west adds the farthest west cell that can be moved to to the
     * top of the path
     */
    public void west()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x - 1, y));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                x--;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    /**
     * move to the north adds the farthest north cell that can be moved to to
     * the top of the path
     */
    public void north()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x, y - 1));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                y--;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    /**
     * move to the south adds the farthest south cell that can be moved to to
     * the top of the path
     */
    public void south()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x, y + 1));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                y++;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    /**
     * Level 0
     */
    public void level0()
    {
        setStart(new Location(1, 5));
        setGoal(new Location(5, 1));
    }


    /**
     * Level 1
     */
    public void level1()
    {
        // implement level1
    }


    /**
     * Level 2
     */
    public void level2()
    {
        // implement level2
    }


    /**
     * Level 3
     */
    public void level3()
    {
        // implement level3
    }


    /**
     * Level 4
     */
    public void level4()
    {
        // implement level4
    }
}
