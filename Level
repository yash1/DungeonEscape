// -------------------------------------------------------------------------
/**
 * Level handles all of the data manipulation of the dungeon escape game In the
 * MVC architecture, Level is the controller
 * 
 * @author Joe Bruzek, Yash Pant, Marcus Stewart
 * @version Dec 4, 2013
 */
public class Level
{

    private Location                    currentLocation;
    private Location                    start;
    private Location                    goal;
    private Cell[][]                    dungeon;
    private int                         size;
    private DoublyLinkedDeque<Location> path;


    // ----------------------------------------------------------
    /**
     * Create a new Level object.
     * 
     * @param size
     *            the size of the level
     */
    public Level(int size)
    {
        dungeon = new Cell[size][size];
        this.size = size;

        for (int i = 1; i < size - 1; i++)
        {
            for (int j = 1; j < size - 1; j++)
            {
                dungeon[i][j] = Cell.OPEN_PATH;
            }
        }

        for (int i = 0; i < size; i++)
        {
            dungeon[i][0] = Cell.WALL;
            dungeon[i][size - 1] = Cell.WALL;
            dungeon[0][i] = Cell.WALL;
            dungeon[size - 1][i] = Cell.WALL;
        }

        start = new Location(0, 0);
        currentLocation = start;
        goal = new Location(size - 1, size - 1);
        setCell(start, Cell.OPEN_PATH);
        setCell(goal, Cell.OPEN_PATH);
        path = new DoublyLinkedDeque<Location>();
        path.enqueueAtFront(currentLocation);
    }


    /**
     * place a wall at the location
     * 
     * @param loc
     *            the location to place a new wall
     */
    public void placeWalls(Location loc)
    {
        if (!loc.equals(start) && !loc.equals(goal))
        {
            dungeon[loc.x()][loc.y()] = Cell.WALL;
        }
    }


    /**
     * set the current location
     * 
     * @param loc
     *            the location to be the new current
     */
    public void setCurrentLocation(Location loc)
    {
        currentLocation = loc;
        path.enqueueAtFront(loc);
    }


    /**
     * return the current location in a location object
     * 
     * @return the current location
     */
    public Location getCurrentLocation()
    {
        return currentLocation;
    }


    /**
     * return the deque that holds the path of the dungeon explorer
     * 
     * @return the path through the dungeon
     */
    public DoublyLinkedDeque<Location> getPath()
    {
        return path;
    }


    /**
     * remove the wall at the current location if there is no wall, nothing
     * happens
     * 
     * @param loc
     *            the location to remove the walls at
     */
    public void removeWalls(Location loc)
    {
        if (dungeon[loc.x()][loc.y()] == Cell.WALL)
        {
            dungeon[loc.x()][loc.y()] = Cell.OPEN_PATH;
        }
    }


    /**
     * set the cell to a specific cell value If the cell is the start or the
     * goal, nothing happens
     * 
     * @param loc
     *            the location to have the cell changed
     * @param cell
     *            the cell value for the location to be changed to
     */
    public void setCell(Location loc, Cell cell)
    {
        if (!loc.equals(start) && !loc.equals(goal))
        {
            dungeon[loc.x()][loc.y()] = cell;
        }
    }


    /**
     * set the goal location cannot be a wall or a hazard
     * 
     * @param loc
     *            the location to place the goal
     */
    public void setGoal(Location loc)
    {
        if (getCell(loc) != Cell.WALL && getCell(loc) != Cell.HAZARD)
        {
            goal = loc;
        }
    }


    /**
     * set the start location cannot be a wall or a hazard
     * 
     * @param loc
     *            the location to place the start
     */
    public void setStart(Location loc)
    {
        if (getCell(loc) != Cell.WALL && getCell(loc) != Cell.HAZARD)
        {
            start = loc;
            path.clear();
            setCurrentLocation(loc);
        }
    }


    /**
     * get the value of the cell at the location
     * 
     * @param loc
     *            the location to get the cell value
     */
    public Cell getCell(Location loc)
    {
        return dungeon[loc.x()][loc.y()];
    }


    /**
     * restart the dungeon level all path is removed and changed to open path
     * start and goal are reset to their original locations
     */
    public void restart()
    {
        for (int i = 1; i < size - 1; i++)
        {
            for (int j = 1; j < size - 1; j++)
            {
                if (dungeon[i][j] == Cell.CURRENT_PATH)
                {
                    dungeon[i][j] = Cell.OPEN_PATH;
                }
            }
        }
        setGoal(goal);
        setStart(start);
    }


    /**
     * move to the east adds the farthest east cell that can be moved to to the
     * top of the path
     */
    public void east()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x + 1, y));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                x++;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    /**
     * move to the west adds the farthest west cell that can be moved to to the
     * top of the path
     */
    public void west()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x - 1, y));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                x--;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    /**
     * move to the north adds the farthest north cell that can be moved to to
     * the top of the path
     */
    public void north()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x, y - 1));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                y--;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }


    /**
     * move to thesouth adds the farthest south cell that can be moved to to the
     * top of the path
     */
    public void south()
    {
        int x = currentLocation.x();
        int y = currentLocation.y();
        boolean temp = true;

        while (temp)
        {
            Cell next = getCell(new Location(x, y + 1));
            if (next != Cell.HAZARD && next != Cell.WALL)
            {
                y++;
            }
            else
            {
                path.enqueueAtFront(new Location(x, y));
                currentLocation = new Location(x, y);
                temp = false;
            }
        }
    }

}
